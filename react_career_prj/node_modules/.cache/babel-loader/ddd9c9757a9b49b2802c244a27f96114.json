{"ast":null,"code":"'use strict';\n\nvar htmlparser2 = require('htmlparser2');\n\nvar domhandler = require('domhandler');\n/**\n * Check if the DOM element is a tag.\n *\n * `isTag(type)` includes `<script>` and `<style>` tags.\n *\n * @private\n * @param {Node} type - DOM node to check.\n * @returns {boolean}\n */\n\n\nexports.isTag = htmlparser2.DomUtils.isTag;\n/**\n * Convert a string to camel case notation.\n *\n * @private\n * @param {string} str - String to be converted.\n * @returns {string} String in camel case notation.\n */\n\nexports.camelCase = function (str) {\n  return str.replace(/[_.-](\\w|$)/g, function (_, x) {\n    return x.toUpperCase();\n  });\n};\n/**\n * Convert a string from camel case to \"CSS case\", where word boundaries are\n * described by hyphens (\"-\") and all characters are lower-case.\n *\n * @private\n * @param {string} str - String to be converted.\n * @returns {string} String in \"CSS case\".\n */\n\n\nexports.cssCase = function (str) {\n  return str.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n/**\n * Iterate over each DOM element without creating intermediary Cheerio instances.\n *\n * This is indented for use internally to avoid otherwise unnecessary memory\n * pressure introduced by _make.\n *\n * @param {Cheerio} cheerio - Cheerio object.\n * @param {Function} fn - Function to call.\n * @returns {Cheerio} The original instance.\n */\n\n\nexports.domEach = function (cheerio, fn) {\n  var i = 0;\n  var len = cheerio.length;\n\n  while (i < len && fn.call(cheerio, i, cheerio[i]) !== false) ++i;\n\n  return cheerio;\n};\n/**\n * Create a deep copy of the given DOM structure. Sets the parents of the copies\n * of the passed nodes to `null`.\n *\n * @private\n * @param {Node | Node[]} dom - The htmlparser2-compliant DOM structure.\n * @returns {Node[]} - The cloned DOM.\n */\n\n\nexports.cloneDom = function (dom) {\n  var clone = 'length' in dom ? Array.prototype.map.call(dom, function (el) {\n    return domhandler.cloneNode(el, true);\n  }) : [domhandler.cloneNode(dom, true)]; // Add a root node around the cloned nodes\n\n  var root = new domhandler.Document(clone);\n  clone.forEach(function (node) {\n    node.parent = root;\n  });\n  return clone;\n};\n/**\n * A simple way to check for HTML strings. Tests for a `<` within a string,\n * immediate followed by a letter and eventually followed by a `>`.\n *\n * @private\n */\n\n\nvar quickExpr = /<[a-zA-Z][^]*>/;\n/**\n * Check if string is HTML.\n *\n * @private\n * @param {string} str - String to check.\n * @returns {boolean} Indicates if `str` is HTML.\n */\n\nexports.isHtml = function (str) {\n  // Run the regex\n  return quickExpr.test(str);\n};","map":{"version":3,"sources":["/Users/lhwn/Documents/workspace/react_career_prj/node_modules/cheerio/lib/utils.js"],"names":["htmlparser2","require","domhandler","exports","isTag","DomUtils","camelCase","str","replace","_","x","toUpperCase","cssCase","toLowerCase","domEach","cheerio","fn","i","len","length","call","cloneDom","dom","clone","Array","prototype","map","el","cloneNode","root","Document","forEach","node","parent","quickExpr","isHtml","test"],"mappings":"AAAA;;AACA,IAAIA,WAAW,GAAGC,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAE,OAAO,CAACC,KAAR,GAAgBJ,WAAW,CAACK,QAAZ,CAAqBD,KAArC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAD,OAAO,CAACG,SAAR,GAAoB,UAAUC,GAAV,EAAe;AACjC,SAAOA,GAAG,CAACC,OAAJ,CAAY,cAAZ,EAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACjD,WAAOA,CAAC,CAACC,WAAF,EAAP;AACD,GAFM,CAAP;AAGD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAR,OAAO,CAACS,OAAR,GAAkB,UAAUL,GAAV,EAAe;AAC/B,SAAOA,GAAG,CAACC,OAAJ,CAAY,QAAZ,EAAsB,KAAtB,EAA6BK,WAA7B,EAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAV,OAAO,CAACW,OAAR,GAAkB,UAAUC,OAAV,EAAmBC,EAAnB,EAAuB;AACvC,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,GAAG,GAAGH,OAAO,CAACI,MAAlB;;AACA,SAAOF,CAAC,GAAGC,GAAJ,IAAWF,EAAE,CAACI,IAAH,CAAQL,OAAR,EAAiBE,CAAjB,EAAoBF,OAAO,CAACE,CAAD,CAA3B,MAAoC,KAAtD,EAA6D,EAAEA,CAAF;;AAC7D,SAAOF,OAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAZ,OAAO,CAACkB,QAAR,GAAmB,UAAUC,GAAV,EAAe;AAChC,MAAIC,KAAK,GACP,YAAYD,GAAZ,GACIE,KAAK,CAACC,SAAN,CAAgBC,GAAhB,CAAoBN,IAApB,CAAyBE,GAAzB,EAA8B,UAAUK,EAAV,EAAc;AAC1C,WAAOzB,UAAU,CAAC0B,SAAX,CAAqBD,EAArB,EAAyB,IAAzB,CAAP;AACD,GAFD,CADJ,GAII,CAACzB,UAAU,CAAC0B,SAAX,CAAqBN,GAArB,EAA0B,IAA1B,CAAD,CALN,CADgC,CAQhC;;AACA,MAAIO,IAAI,GAAG,IAAI3B,UAAU,CAAC4B,QAAf,CAAwBP,KAAxB,CAAX;AACAA,EAAAA,KAAK,CAACQ,OAAN,CAAc,UAAUC,IAAV,EAAgB;AAC5BA,IAAAA,IAAI,CAACC,MAAL,GAAcJ,IAAd;AACD,GAFD;AAIA,SAAON,KAAP;AACD,CAfD;AAiBA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIW,SAAS,GAAG,gBAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA/B,OAAO,CAACgC,MAAR,GAAiB,UAAU5B,GAAV,EAAe;AAC9B;AACA,SAAO2B,SAAS,CAACE,IAAV,CAAe7B,GAAf,CAAP;AACD,CAHD","sourcesContent":["'use strict';\nvar htmlparser2 = require('htmlparser2');\nvar domhandler = require('domhandler');\n\n/**\n * Check if the DOM element is a tag.\n *\n * `isTag(type)` includes `<script>` and `<style>` tags.\n *\n * @private\n * @param {Node} type - DOM node to check.\n * @returns {boolean}\n */\nexports.isTag = htmlparser2.DomUtils.isTag;\n\n/**\n * Convert a string to camel case notation.\n *\n * @private\n * @param {string} str - String to be converted.\n * @returns {string} String in camel case notation.\n */\nexports.camelCase = function (str) {\n  return str.replace(/[_.-](\\w|$)/g, function (_, x) {\n    return x.toUpperCase();\n  });\n};\n\n/**\n * Convert a string from camel case to \"CSS case\", where word boundaries are\n * described by hyphens (\"-\") and all characters are lower-case.\n *\n * @private\n * @param {string} str - String to be converted.\n * @returns {string} String in \"CSS case\".\n */\nexports.cssCase = function (str) {\n  return str.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\n/**\n * Iterate over each DOM element without creating intermediary Cheerio instances.\n *\n * This is indented for use internally to avoid otherwise unnecessary memory\n * pressure introduced by _make.\n *\n * @param {Cheerio} cheerio - Cheerio object.\n * @param {Function} fn - Function to call.\n * @returns {Cheerio} The original instance.\n */\nexports.domEach = function (cheerio, fn) {\n  var i = 0;\n  var len = cheerio.length;\n  while (i < len && fn.call(cheerio, i, cheerio[i]) !== false) ++i;\n  return cheerio;\n};\n\n/**\n * Create a deep copy of the given DOM structure. Sets the parents of the copies\n * of the passed nodes to `null`.\n *\n * @private\n * @param {Node | Node[]} dom - The htmlparser2-compliant DOM structure.\n * @returns {Node[]} - The cloned DOM.\n */\nexports.cloneDom = function (dom) {\n  var clone =\n    'length' in dom\n      ? Array.prototype.map.call(dom, function (el) {\n          return domhandler.cloneNode(el, true);\n        })\n      : [domhandler.cloneNode(dom, true)];\n\n  // Add a root node around the cloned nodes\n  var root = new domhandler.Document(clone);\n  clone.forEach(function (node) {\n    node.parent = root;\n  });\n\n  return clone;\n};\n\n/**\n * A simple way to check for HTML strings. Tests for a `<` within a string,\n * immediate followed by a letter and eventually followed by a `>`.\n *\n * @private\n */\nvar quickExpr = /<[a-zA-Z][^]*>/;\n\n/**\n * Check if string is HTML.\n *\n * @private\n * @param {string} str - String to check.\n * @returns {boolean} Indicates if `str` is HTML.\n */\nexports.isHtml = function (str) {\n  // Run the regex\n  return quickExpr.test(str);\n};\n"]},"metadata":{},"sourceType":"script"}